**Министерство науки и высшего образования Российской Федерации**

**федеральное государственное бюджетное**

**образовательное учреждение высшего образования**

**«Российский экономический университет имени Г.В. Плеханова»**

Высшая школа кибертехнологий, математики и статистики

Базовая кафедра цифровой экономики института развития информационного общества



**КУРСОВАЯ РАБОТА**

по дисциплине «Структуры и алгоритмы компьютерной обработки данных»

на тему «Генерация комбинаторных объектов»



Выполнил обучающийся группы 15.11Д-МОСИП12/21б

очной формы обучения 

Высшей школы кибертехнологий
математики и статистики
Степаниденко Д.Е.

Научный руководитель: 

Комлева Нина Викторовна

Москва – 2023 г.



# **Оглавление**
# [ВВЕДЕНИЕ](#_toc131123587)

# [Глава 1. Теоретические основы генерации комбинаторных объектов	](#_toc131123588)

## [1.1	Постановка задачи	](#_toc131123589)

## [1.2	Перестановки	](#_toc131123590)

## [1.2.1	Алгоритм Штейнхауза-Джонсона-Троттера	](#_toc131123591)

## [1.2.2	Алгоритм Хипа	](#_toc131123592)

## [1.3	Разбиение чисел на слагаемые](#_toc131123593)

## [1.3.1	Генерации разбиения числа с помощью динамического программирования](#_toc131123594)

## [1.4	Разбиение числа n на m слагаемых](#_toc131123595)

## [1.4.1	Алгоритм Карла Фридриха Гинденбурга](#_toc131123596)

# [Глава 2. Разработка программ](#_toc131123597)

## [2.1	Разработка алгоритма Хипа](#_toc131123598)

## [2.2    Разработка алгоритма генерации всех разбиений числа с помощью динамического программирования](#_toc131123599)

## [2.3	Разработка алгоритма Карла Фридриха Гинденбурга](#_toc131123600)

# [Глава 3. Машинный эксперимент](#_toc131123601)

## [3.1	Тестирование алгоритма Хипа](#_toc131123602)

## [3.2	Тестирование алгоритма динамического программирования для генерации всех разбиений числа на слагаемые](#_toc131123603)

## [3.3	Тестирование алгоритма Карла Фридриха Гинденбурга](#_toc131123604)

# [Заключение](#_toc131123605)

# [Список литературы](#_toc131123606)

# [Приложения](#_toc131123607)

##  [Приложение 1](#_toc131123608)

### [Алгоритм Карла Фридриха Гинденбурга](#_toc131123609)

## [Приложение 2](#_toc131123610)

### [Алгоритм Хипа](#_toc131123611)

## [Приложение 3](#_toc131123612)

### [Алгоритм генерации разбиения числа с помощью динамического программирования](#_toc131123613)






# <a name="_toc131123587"></a>ВВЕДЕНИЕ

## Актуальность темы исследования

Тема исследования генерации комбинаторных объектов является актуальной и важной в различных областях науки и техники, таких как математика, информатика, физика, биология и другие.

Комбинаторика - это наука, изучающая комбинаторные структуры и комбинаторные объекты, такие как перестановки, сочетания, разбиения и т.д. Генерация комбинаторных объектов - это процесс создания всех возможных комбинаций объектов, которые удовлетворяют определенным критериям.

Генерация комбинаторных объектов имеет множество практических применений. Например, в анализе данных генерация комбинаторных объектов может использоваться для создания всех возможных вариантов сценариев исхода событий, которые могут произойти в заданной ситуации. В криптографии генерация комбинаторных объектов может использоваться для создания всех возможных паролей, которые могут быть использованы для взлома защиты. В математике генерация комбинаторных объектов может быть полезна для создания новых теорем и формулирования гипотез.

Кроме того, генерация комбинаторных объектов является важной темой исследования в информатике и компьютерной науке. Эта тема имеет множество применений в областях, таких как алгоритмы оптимизации, искусственный интеллект, машинное обучение и т.д.

Например, алгоритмы генерации комбинаторных объектов могут использоваться для создания тестовых данных для тестирования программного обеспечения, для оптимизации производственных процессов в промышленности и для решения других задач в различных областях.

Таким образом, генерация комбинаторных объектов является важной темой исследования, которая имеет множество практических применений в различных областях науки и техники.

## Цель и задачи курсовой работы

Целью курсовой работы является разработка, написание и тестирование программного средства для решения задач по генерации комбинаторных объектов.

Для реализации поставленной цели, необходимо решить следующие задачи: 

1\.	Изучить различную литературу по данной теме;

2\.	Рассмотреть различные алгоритмы и их особенности;

3\.	Разработка, написание и тестирование программ, реализующих изученные алгоритмы.

## Объект исследования

Структуры и алгоритмы компьютерной обработки данных

## Предмет исследования

Использование различных алгоритмов и методов генерации комбинаторных объектов, их свойств, анализ эффективности их работы на различных входных данных.

## Методы исследования

1) Анализ литературы - изучение научных статей, учебников и других публикаций, посвященных теме генерации комбинаторных объектов.
1) Экспериментальные методы - тестирование алгоритмов и методов генерации комбинаторных объектов на различных входных данных, анализ их эффективности и точности.
1) Математические методы - применение математических методов для изучения свойств комбинаторных объектов и алгоритмов их генерации.

## Структура работы

Первая глава курсовой работы посвящена теоретической части. В ней подробно разобраны определения, связанные с комбинаторикой. Представлено постановка задачи, а также различные алгоритмы для её реализации.

Вторая глава рассказывает про процесс создания программы. Для полного понимания представлены фрагменты кода программы

В третьей главе рассматривается тестирование  программы. Создаются реальные условия, в которых происходит тестирование. Также представлены скриншоты работы программы. Результат тестирование показывает, что программа работает успешно и справляется с заданными задачами.



# <a name="_toc42962900"></a><a name="_toc43133193"></a><a name="_toc105095958"></a><a name="_toc131123588"></a>Глава 1. Теоретические основы генерации комбинаторных объектов

## 1. <a name="_toc131123589"></a>Постановка задачи

Задача генерации комбинаторных объектов состоит в том, чтобы создавать наборы объектов в соответствии с заданными комбинаторными правилами.

Комбинаторные объекты могут быть различными, в зависимости от того, какие правила задаются. Некоторые из них включают перестановки, сочетания, разбиения чисел на слагаемые, графы, деревья, последовательности и многие другие.

При генерации комбинаторных объектов основной вопрос заключается в том, каким образом эти объекты должны быть сгенерированы. Существует множество методов для решения этой задачи, например, методы, основанные на рекурсии, алгоритмы перебора и комбинаторные методы.

Кроме того, важно учитывать, каким образом будут использоваться комбинаторные объекты, полученные при решении задачи. Например, в задачах оптимизации комбинаторные объекты могут использоваться для поиска оптимального решения, а в задачах криптографии - для создания криптографических ключей.

Одной из сложностей при решении задачи генерации комбинаторных объектов является вычислительная сложность. Некоторые комбинаторные объекты могут иметь очень большое число возможных комбинаций, что может существенно затруднить их генерацию и использование.

В своей курсовой работе я рассмотрю две важные задачи – генерация перестановок и разбиение чисел на слагаемые.

## 2. <a name="_toc131123590"></a>Перестановки

Перестановки - это комбинаторный объект, который описывает все возможные способы переставления элементов множества. Формально, перестановка - это упорядоченный набор из n элементов, в котором каждый элемент появляется ровно один раз.

Общее количество перестановок из n элементов вычисляется как n! (n факториал). Например, для множества из 3 элементов (например, {1, 2, 3}), есть 3! = 6 возможных перестановок: {1, 2, 3}, {1, 3, 2}, {2, 1, 3}, {2, 3, 1}, {3, 1, 2} и {3, 2, 1}.

Перестановки применяются в очень широком спектре областей, таких как:

1) Комбинаторика: перестановки являются одним из основных объектов комбинаторики и используются для решения широкого спектра задач, таких как распределение комитетов, размещение шахматных фигур на доске, выбор паролей и т\.д\.

2) Математический анализ: перестановки используются в теории вероятностей, для вычисления вероятности появления различных исходов, включая распределения случайных событий\.

3) Криптография: перестановки используются для зашифровки и расшифровки сообщений в различных алгоритмах шифрования\.

4) Алгоритмы и оптимизация: перестановки используются в задачах перебора, когда нужно перебрать все возможные варианты для выбора оптимального решения\.

5) Информатика: перестановки используются для решения задач в области искусственного интеллекта, машинного обучения и анализа данных, например, для сортировки и фильтрации больших объемов данных\.

Это лишь некоторые примеры областей, в которых перестановки находят свое применение. Как видно, перестановки являются важным объектом в математике и науке в целом, и их применение охватывает многие области науки и техники, поэтому очень важно изучить алгоритмы, с помощью которых можно генерировать перестановки.

Перейдём к рассмотрению самых популярных алгоритмов генерации перестановок.

## 3. <a name="_toc131123591"></a>Алгоритм Штейнхауза-Джонсона-Троттера

Алгоритм Штейнхауза-Джонсона-Троттера - это алгоритм генерации перестановок без повторений. Он был разработан тремя математиками: Штейнхаузом, Джонсоном и Троттером в 1962 году. Основная идея алгоритма заключается в том, чтобы начать с самой маленькой перестановки (базовая перестановка) и последовательно добавлять элементы до тех пор, пока не будет сформирована полная перестановка. При этом каждый новый элемент добавляется с учетом порядка, заданного дополнительным параметром, который называется направлением.

Направление – указатель на соседний элемент (может указывать на элемент справа или слева). Элемент перестановки называется мобильным, если его направление указывает на меньший соседний элемент.

Рассмотрим описание работы данного алгоритма

1) Создаётся первая перестановка. Ряд чисел по возрастанию 1,2,…,n. Направление каждого элемента указывает влево.
1) Ищем наибольший мобильный элемент. Если не находим, то алгоритм закончен.
1) Производим обмен найденного мобильного элемента с элементом, на который указывает направление найденного мобильного элемента.
1) Меняем направление у всех элементов, которые больше чем найденный на шаге 2 элемент.
1) Переходим к шагу 2.

Преимущества данного алгоритма:

1) Относительная легкость не рекурсивной реализации
1) Малый расход памяти

Заметим, что данный алгоритм не является рекурсивным, а значит, не потребляет очень больших объёмов памяти, так как не нужно хранить все предыдущие перестановки, а только текущую, данное замечание как раз и является преимуществом этого алгоритма.

Поговорим об асимптотике данного алгоритма

Сложность по времени в наихудшем случае – O(n!)

Затраты памяти – O(n), где n – количество всех элементов в заданной последовательности.

Рассмотрим, как работает данный алгоритм на конкретном примере.

Допустим, нам нужно сгенерировать все перестановки длиной 3. Согласно алгоритму создаём базовый массив a=[1,2,3] и массив направлений b=[←←←] и возвращаем базовую перестановку 1,2,3. Ищем наибольший мобильный элемент – это число 3. Далее меняем в массиве этот элемент, с элементом, на который он указывает и меняем направление у всех элементов, которые больше чем найденный. 

Получаем a=[1,3,2] и b=[←←←] – возвращаем 1,3,2 как текущую перестановку. Ищем наибольший мобильный элемент – это число 3. Далее меняем в массиве этот элемент, с элементом, на который он указывает и меняем направление у всех элементов, которые больше чем найденный.      

Получаем a=[3,1,2] и b=[←←←] – возвращаем 3,1,2 как текущую перестановку. Ищем наибольший мобильный элемент – это число 2 (так как тройка не указывает ни на какой элемент). Далее меняем в массиве этот элемент, с элементом, на который он указывает и меняем направление у всех элементов, которые больше чем найденный. 

Получаем a=[3,2,1] и b=[→←←] – возвращаем 3,2,1 как текущую перестановку. Ищем наибольший мобильный элемент – это число 3. Далее меняем в массиве этот элемент, с элементом, на который он указывает и меняем направление у всех элементов, которые больше чем найденный. 

Получаем a=[2,3,1] и b=[←→←] – возвращаем 2,3,1 как текущую перестановку. Ищем наибольший мобильный элемент – это число 3. Далее меняем в массиве этот элемент, с элементом, на который он указывает и меняем направление у всех элементов, которые больше чем найденный. 

Получаем a=[2,1,3] и b=[←←→] – возвращаем 2,1,3 как текущую перестановку. Но как мы видим теперь в нашем массиве вообще нет мобильного элемента – значит алгоритм завершается.

## 4. <a name="_toc131123592"></a>Алгоритм Хипа

Следующий алгоритм для генерации перестановок, который мы рассмотрим это алгоритм Хипа, названный в честь B.R. Heap, который открыл его в 1963 году. Алгоритм минимизирует перемещение: он генерирует каждую перестановку из предыдущей путём замены одной пары элементов; остальные (n-2) элемента не нарушаются. В 1977 году в обзоре алгоритмов генерации перестановок Роберт Седжвик (американский специалист по информатике) пришёл к выводу, что на тот момент это был наиболее эффективный алгоритм для генерации перестановок с помощью компьютера.

Рассмотрим описание данного алгоритма

Для первого вызова функции используем последовательность (из элементов которой хотим получить перестановки) и значение k равное её длине.

1) Проверить значение k\. В случае k == 1 -> вернуть последовательность как текущую перестановку\. Закончить вызов функции\.

2)	Используя цикл от индекса первого элемента последовательности до k с шагом в 1 выполнить действия:

    2.1) 	Рекурсивно вызвать функцию передав последовательность и значение (k-1).

    2.2) 	Если k чётное выполнить обмен i и k элемента местами, в противном случае выполнить обмен первого элемента последовательности и k.

Рассмотрим асимптотику данного алгоритма.

Сложность по времени – O(n!).

Сложность по памяти – O(n) - для рекурсивного стекового пространства размером n, где n – размер изначально заданной последовательности.

Давайте рассмотрим пример работы алгоритма на конкретном примере.

Пусть у нас есть массив a = [1,2,3]  и мы хотим сгенерировать все перестановки элементов данного массива. Введём переменную k, которая изначально будет показывать длину массива, то есть k=3. Автор предложил этот алгоритм, основываясь на индексации массива с 1. У нас переменная k не равняется единице, значит вызываем для каждого элемента с начала и до k-го элемента эту функцию с параметром на единицу меньше. Для начала вызовем функция для элемента 1 с параметром k-1=3-1=2. Получаем, что a = [1,2,3]   и  k=2. У нас переменная k  не равняется единице, значит вызываем для каждого элемента с начала и до k-го элемента эту функцию с параметром на единицу меньше. То есть вызываем для 1 элемента функцию с параметром k-1=2-1=1. Переменная k равняется одному, значит возвращаем данную перестановку как следующую – то есть 1,2,3. Далее функция возвращает управление на момент, где a = [1,2,3] и   k=2. Далее сама идея Хипа, мы должны поменять элементы. У нас k – чётное число, а значит меняем местами k-ый элемент и тот с которым только что работали – то есть первым элементом. То есть получаем a = [2,1,3] и k=2. Теперь вызываем функцию для второго элемента с параметром k-1=2-1=1. То есть получаем a = [2,1,3] и k=1. Переменная k  равняется одному, значит возвращаем данную перестановку как следующую – то есть 2,1,3. Далее функция возвращает управление на момент, где a = [2,1,3] и   k=2.

У нас k – чётное число, а значит меняем местами k-ый элемент и тот с которым только что работали, то есть со вторым элементом. Но k-ый элемент и так указывает на второй элемент, с которым мы только что работали, значит функция возвращает управление на момент, где a = [2,1,3] и   k=3. В данном случае k – нечётное число, следовательно делаем обмен первого элемента последовательности и k. То есть получаем a = [3,1,2] и   k=3. 

Теперь рекурсивно вызываем функцию, но уже от второго элемента с параметром k-1=3-1=2. У нас переменная k  не равняется единице, значит вызываем для каждого элемента с начала и до k-го элемента эту функцию с параметром на единицу меньше. То есть вызываем для 1 элемента функцию с параметром k-1=2-1=1. Переменная k равняется одному, значит возвращаем данную перестановку как следующую – то есть 3,1,2. 

Далее функция возвращает управление на момент, где a = [3,1,2] и   k=2. У нас k – чётное число, а значит меняем местами k-ый элемент и тот с которым только что работали – то есть первым элементом. То есть получаем a = [1,3,2] и k=2. Теперь вызываем функцию для второго элемента с параметром k-1=2-1=1. Переменная k равняется одному, значит возвращаем данную перестановку как следующую – то есть 1,3,2. Далее функция возвращает управление на момент, где a = [1,3,2] и   k=2. У нас k – чётное число, а значит меняем местами k-ый элемент и тот с которым только что работали, то есть со вторым элементом. Но  k-ый элемент и так указывает на второй элемент, с которым мы только что работали, значит функция возвращает управление на момент, где a = [1,3,2] и   k=3. В данном случае k – нечётное число, следовательно делаем обмен первого элемента последовательности и k. То есть получаем a = [2,3,1] и   k=3. И теперь остаётся вызывать рекурсивно функцию для последнего элемента с параметром k-1=3-1=2. У нас переменная k  не равняется единице, значит вызываем для каждого элемента с начала и до k-го элемента эту функцию с параметром на единицу меньше. То есть вызываем для 1 элемента функцию с параметром k-1=2-1=1. Переменная k равняется одному, значит возвращаем данную перестановку как следующую – то есть 2,3,1. 

Далее функция возвращает управление на момент, где a = [2,3,1] и   k=2. У нас k – чётное число, а значит меняем местами k-ый элемент и тот с которым только что работали – то есть первым элементом. То есть получаем a = [3,2,1] и k=2. Теперь вызываем функцию для второго элемента с параметром k-1=2-1=1. Переменная k равняется одному, значит возвращаем данную перестановку как следующую – то есть 3,2,1. У нас k – чётное число, а значит меняем местами k-ый элемент и тот с которым только что работали, то есть со вторым элементом. Но  k-ый элемент и так указывает на второй элемент, с которым мы только что работали, значит функция возвращает управление на момент, где a = [3,2,1] и   k=3. Но на данном этапе мы прошли все элементы от 1 до k – значит алгоритм завершает свою работу.

## 5. <a name="_toc131123593"></a>Разбиение чисел на слагаемые

Задача о разбиении чисел на слагаемые заключается в том, чтобы найти все способы представления натурального числа n в виде суммы положительных целых чисел. Например, число 5 можно разбить на слагаемые несколькими способами: 5, 4+1, 3+2, 3+1+1, 2+2+1, 2+1+1+1, 1+1+1+1+1. При этом разбиения, отличающиеся только порядком частей, считаются равными.

Задача о разбиении чисел на слагаемые имеет множество исследовательских и практических задач, связанных с поиском оптимальных алгоритмов, изучением свойств различных видов разбиений и их применением в решении задач оптимизации и проектировании систем. В данной задачи важным является также изучение свойств различных видов разбиений, таких как упорядоченные, неупорядоченные, с повторениями, без повторений и т.д. Это позволяет рассматривать задачу о разбиении чисел на слагаемые с различных точек зрения и применять ее в различных областях.

Кроме того, задача о разбиении чисел на слагаемые имеет интересные математические свойства, которые могут быть использованы для исследования других комбинаторных задач. Например, теория разбиения чисел на слагаемые используется в теории представлений, теории модулей, теории функций Лиувилля и теории модулярных форм.

Одним из приложений задачи о разбиении чисел на слагаемые является проблема расписания. Например, если некоторая компания должна выполнить задачу, которая занимает n единиц времени, и у нее есть m работников с разной производительностью, то задача расписания может быть решена путем разбиения n на m слагаемых, где каждое слагаемое соответствует количеству времени, которое каждый работник должен потратить на выполнение задачи.

К тому же, задача о разбиении чисел на слагаемые может быть использована для моделирования ряда прикладных задач, например, для анализа производительности сетей связи, распределения производственных ресурсов и оптимизации процесса обработки данных.

Таким образом, задача о разбиении чисел на слагаемые имеет широкий спектр приложений и может быть использована для решения различных задач в различных областях, начиная от математики и заканчивая прикладными задачами в инженерии и экономике, поэтому её значение очень велико.

Давайте рассмотрим алгоритм, который с помощью динамического программирования генерирует все разбиения. 

## 6. <a name="_toc131123594"></a>Генерации разбиения числа с помощью динамического программирования

Опишем сам алгоритм:

1) Создаём последовательность длиной n. Заполняем её единицами. Переходим к шагу 2.
1) Если длина последовательности равна 1, то заканчиваем алгоритм. В противном случае последовательность есть следующее разбиение. Используем его и переходим к шагу 3.
1) Находим ближайший к началу последовательности минимальный элемент (поиск проводим от начала до предпоследнего элемента). Увеличиваем его на единицу. Уменьшаем на единицу последний элемент последовательности. Вычисляем сумму элементов правее найденного минимального элемента. Создаём новую последовательность из элементов предыдущей последовательности, начиная с начала и до найденного минимального элемента и такого количества единиц, как найденная ранее сумма. Переходим в шагу 2.

Рассмотрим сложность алгоритма.

Сложность по времени в наихудшем случае – O(n).

Затраты памяти – O(n).

Где n – искомое число, разбиение которого мы хотим найти.

Но внимание – это на одно разбиение, а как мы выяснили ранее, количество разбиений возрастает очень быстро, поэтому на больших данных алгоритм будет работать очень долго.

Давайте посмотрим на то, как работает этот алгоритм на конкретном примере.

Пусть нам дано число  n=5. Согласно алгоритму мы создаём массив a=[1,1,1,1,1]. Далее проверяем длину этого массива – она не равна одному, а значит это и есть текущее разбиение, то есть записываем 1,1,1,1,1 как наше первое разбиение.

Затем ищем минимальный элемент, начиная с начала массива и до предпоследнего элемента – это число 1. Увеличиваем этот элемент на 1, а последний уменьшаем на единицу. Получаем a=[2,1,1,1,0]. Вычисляем сумму элементов правее минимального и до конца (будем обозначать далее её как S). В нашем случае S=3. И создаём новый массив, в котором будут элементы из начало старого до минимального элемента и столько единиц, какова суммы S. По итогу получаем a=[2,1,1,1]. Это и есть наше следующее разбиение, то есть 2,1,1,1. 

Ищем минимальный элемент в новом массиве – это опять число 1. Увеличиваем его на единицу, а также уменьшаем последний элемент на 1. 

Получаем a=[2,2,1,0] и S=1. Теперь новый массив это a=[2,2,1]. Это и есть наше следующее разбиение, то есть 2,2,1. Ищем минимальный элемент в новом массиве – это число 2 (так как смотрим от начального до предпоследнего элемента). Увеличиваем минимальный элемент на 1, а также последний уменьшаем на 1. Получаем a=[3,2,0] и S=2. Теперь новый массив это a=[3,1,1], а следовательно мы нашли ещё одно разбиение.

Ищем минимальный элемент в новом массиве – это число 1.Увеличиваем его на единицу, а также последний уменьшаем на единицу. Получаем a=[3,2,0] и S=0. 

Теперь новый массив это a=3,2, а также наше новое разбиение. Ищем минимальный элемент от начало до предпоследнего элемента – это число 3. Увеличиваем его на единицу, а также последний уменьшаем на 1. Получаем a=[4,1] и S=1. 

Теперь новый массив это a=4,1 – это и есть наше следующее разбиение.  Теперь ищем минимальный элемент от начала до предпоследнего элемента – это число 5. Увеличиваем его на 1, а также последний уменьшаем на 1. Получаем a=[5,0] и S=0. 

Теперь новый массив a=5 – как мы видим, длина этого массива равняется единицы, а значит согласно алгоритму – мы нашли все разбиения на слагаемые числа 5.

## 7. <a name="_toc131123595"></a>Разбиение числа n на m слагаемых

Задача разбиения числа n на m слагаемых заключается в том, чтобы найти все возможные способы представления числа n в виде суммы m неотрицательных целых чисел.

Другими словами, нам нужно найти все упорядоченные наборы из m неотрицательных целых чисел, сумма которых равна n. Заметим, что порядок частей в разбиении не имеет значения, то есть разбиение 1+1+3 эквивалентно, например разбиению 3+1+1.

При этом должно выполняться условие, что n>=m>=2.

Например, разбиение числа 8 на 4 части можно представить так:

1) 8 = 5+1+1+1
1) 8 = 4+2+1+1
1) 8 = 3+3+1+1
1) 8 = 3+2+2+1
1) 8 = 2+2+2+2

Данная задача является фундаментальной в теории чисел, а также применяется во многих областях, таких как криптография, экономика, поэтому её рассмотрение столь важно.

Рассмотрим алгоритм, который реализует поставленную задачу.

## 8. <a name="_toc131123596"></a>Алгоритм Карла Фридриха Гинденбурга

Рассмотрим алгоритм, который был предложен в 1779 г.  немецким математиком К.Ф.Гиденбургом.

Посмотрим описание алгоритма:

1) 	Создаём последовательность a длинной m\. Устанавливаем a0=n-m+1, остальные элементы равные 1\.Переходим к шагу 2\.

2) 	Возвращаем последовательность в качестве разбиения\. Выполнить проверку a1< a0-1 , если это условие истинно, то перейти к шагу 3, в противном случае перейти к шагу 4\.

3) 	Установить a0=a0-1 , a1=a1+1\. Перейти к шагу 2\.

4)  Начиная со второго элемента последовательности, ищем элемент удовлетворяющий условию aj<a0-1\. Если такого элемента не найдено, то заканчиваем алгоритм\. Вычисляем сумму всех элементов до найденного элемента минус 1 (обозначим сумма как S)\. Увеличим значение найденного элемента на единицу\. Перейти к шагу 5\.

5)  Выполняем проход от второго элемента до найденного элемента последовательности\. На каждом шагу устанавливаем значение равное значению найденного элемента, при этом уменьшая значение S на эту величину\. После завершения прохода, устанавливаем значение первого элемента последовательности как S\. Перейти к шагу 2\. 

Рассмотрим сложность алгоритма.

Сложность по времени в наихудшем случае – O(m)

Но обратим внимание, что сложность указана для одного разбиения, а как мы выяснили ранее, количество разбиений при n→∞ растёт экспоненциально, то есть очень быстро. Это означает, что на больших данных программа будет выполняться очень и очень долго.

Рассмотрим подробно, как работает алгоритм на конкретном примере.

Пусть нам нужно разбить число n=8 на m=4 части.

Согласно алгоритму нам нужно создать масcив a из четырёх элементов, где a0=n-m+1=8-4+1=5, остальные элементы заполняем единичками. То есть a=[5,1,1,1] – это и есть наше первое разбиение.

Далее проверяем условие a1< a0-1 – для нашего массива это выполнено (1<4), значит устанавливаем a0=a0-1 , a1=a1+1 и возвращаем полученное разбиение, то есть a=[4,2,1,1]. Проверяем условие a1< a0-1, для нашего массива это выполнено(2<3), значит устанавливаем a0=a0-1 , a1=a1+1 и возвращаем полученное разбиение, то есть a=[3,3,1,1].

Проверяем условие a1< a0-1, но для нашего массива это уже не выполнено. Значит, начиная со второго элемента последовательности, ищем элемент удовлетворяющий условию aj<a0-1 – как мы можем видеть это число 1.Вычисляем сумму элементов (далее будем обозначать её как S)  от начального до aj, не включая его, и вычитаем из этой суммы один. Получаем, что S=3+3-1=5. Увеличиваем aj на единицу и, начиная со второго элемента и до найденного, на каждом шагу устанавливаем значение равное значению найденного элемента, при этом уменьшая значение S на эту величину. После завершения прохода, устанавливаем значение первого элемента последовательности как S. В нашем случае в конце получится a=[3,2,2,1] и S=3, поэтому первый элемент так и остаётся равным трём. И мы как раз получили наше следующее разбиение – это 3,2,2,1. Проверяем условие a1< a0-1, но для нашего нового массива это не выполняется. Значит, начиная со второго элемента последовательности, ищем элемент удовлетворяющий условию aj<a0-1 – как мы можем видеть это число 1. 

Вычисляем сумму элементов от начального до aj, не включая его, и вычитаем из этой суммы один. Получаем, что S=3+2+2-1=6. 

Увеличиваем aj на единицу и, начиная со второго элемента и до найденного, на каждом шагу устанавливаем значение равное значению найденного элемента, при этом уменьшая значение S на эту величину. После завершения прохода, устанавливаем значение первого элемента последовательности как S. В нашем случае в конце получится a=[2,2,2,2] и S=2 и возвращаем полученное новое разбиение. Проверяем условие a1< a0-1, но для нашего массива это не выполнено. Значит, начиная со второго элемента последовательности, ищем элемент удовлетворяющий условию aj<a0-1, но в нашем массиве такого элемента нет – значит завершаем алгоритм.

# <a name="_toc131123597"></a>Глава 2. Разработка программ

## 1. <a name="_toc131123598"></a>Разработка алгоритма Хипа

Как мы помним в алгоритме Хипа мы пользовались рекурсией, а значит создадим функцию HipAlgorithm()(рис.2.1.1), которая не будет ничего возвращать, а лишь выводить перестановки на экран.

![](Aspose.Words.b733c9a5-6fc5-4575-bb81-afe6f7e27189.001.png)

*Рисунок 2.1.1 Функция HipAlgorithm*

На вход мы принимаем сам массив из элементов, перестановки которых мы хотим найти, а также переменную k, которая изначально равняется длине массива. Как мы видим если k=1 , то выводим текущую перестановку. Если нет, то создаём цикл от первого элемента массива до k, и от каждого элемента вызываем функцию с параметром k-1. Также в функции прописана замена элементов, согласно действиям алгоритма. Функция swap создана самостоятельно и показана на рис. 2.1.2.

![](Aspose.Words.b733c9a5-6fc5-4575-bb81-afe6f7e27189.002.png)

*Рисунок 2.1.2. Функция swap*

Функция swap работает крайне просто – принимает на вход массив, и два индекса. А далее с помощью третьей переменной меняем местами элементы массива с заданными индексами.

## <a name="_toc131123599"></a>2. Разработка алгоритма генерации всех разбиений числа с помощью динамического программирования

Создадим функцию getNextPartition()(рис. 2.2.1) , которая будет возвращать следующее разбиение числа на слагаемые.

![](Aspose.Words.b733c9a5-6fc5-4575-bb81-afe6f7e27189.003.png)

*Рисунок 2.2.1 Функция getNextPartition*

На вход данная функция принимает массив, который изначально будет заполнен одними единицами, согласно алгоритму – но потом будет видоизменяться, добавляя новые разбиения заданного числа на слагаемые.

Вначале проверяется длина массива partition. Если равняется единице, то алгоритм завершает свою работу и возвращает пустую ссылку. Если нет, то согласно алгоритму, ищется минимальный элемент – это мы делаем с помощью обычного цикла for. Далее увеличиваем минимальный элемент на единицу, а последний уменьшаем на единицу. Затем с помощью цикла for ищем сумму элементов от минимального и до последнего элемента. И наконец создаём новый массив с помощью копирования старого массива, и новой длиной minIndex+partSum, где partSum – сумма элементов от минимального и до последнего элемента. Операцию копирования элементов в новый массив из старого делаем с помощью метода Arrays.copyOf(). И с помощью цикла for заполняем элементы с индексом от minIndex и до последнего – единицами. Полученный массив и будет следующим разбиением заданного числа на слагаемые. Но это мы только научились создавать следующее разбиение на основе текущего, теперь создадим функцию, которая выведет все разбиения числа – это будет функция printAllNumberPartitions()( рис. 2.2.2).

![](Aspose.Words.b733c9a5-6fc5-4575-bb81-afe6f7e27189.004.png)

*Рисунок 2.2.2 Функция printAllNumberPartitions*

Как мы видим, на вход данная функция принимает число number, разбиение которого мы хотим найти. Далее согласно алгоритму создаётся массив, размером number, и с помощью метода Arrays.fill() заполняется единицами. И наконец с помощью цикла while, генерируются все разбиения числа. Обратим внимание, что условие выхода из цикла, это то, что ссылка на массив partition равняется null, как раз для этого в функции getNextPartition() возвращается ссылка null в случае равенства длины массива partition единице.

## 3. <a name="_toc131123600"></a>Разработка алгоритма Карла Фридриха Гинденбурга

Создадим функцию printAllNumberPartition()(рис. 2.3.1) , которая будет возвращать все разбиения числа n на m слагаемых.

На вход данная функция будет принимать два параметра – число, которое нужно разбить на слагаемые (n), а также число слагаемых (m).

Согласно алгоритму, вначале мы создаём массив длины m, где первый элемент находится по формуле n-m+1. Далее запускаем бесконечный цикл for, в котором проверяем условие  a1< a0-1. Если оно выполняется, то меняем элементы массива с индексами 0 и 1 согласно алгоритму и далее возвращаемся в начало цикла for. Если же оно не выполняется, то ищем элемент удовлетворяющий условию aj<a0-1. Сразу инициализируем переменную s=part0-1 для подсчёта суммы. Обратите внимание, что сразу вычитаем из этой суммы единицу, чтобы в конце не забыть этого сделать. Далее для того чтобы нам понять что такого элемент удовлетворяющего условию aj<a0-1 может и не быть,  устанавливаем значение переменной j, равное -1, чтобы в конце можно было понять, нашли ли мы такой элемент или нет. Если его нашли, то увеличиваем его на единицу, и далее чтобы избежать двух циклов for, в одном цикле приравниваем значения элементов массива к переменной part[j] (тот самый элемент, который мы нашли на предыдущем шаге) и также уменьшаем сумму s на значение этих элементов. И в конце не забываем установить значение первого элемента массива как сумму s.

![](Aspose.Words.b733c9a5-6fc5-4575-bb81-afe6f7e27189.005.png)

*Рисунок 2.3.1 Функция printNumberPartition*


# <a name="_toc131123601"></a>Глава 3. Машинный эксперимент

## 1. <a name="_toc131123602"></a>Тестирование алгоритма Хипа

Пусть у нас есть массив a=[1,2,3,6] и попробуем протестировать алгоритм Хипа и сгенерировать все перестановки элементов данного массива. И также в конце будем выводить время, за которое алгоритм сработал.

Как мы видим на рис. 3.1.1, алгоритм сработал верно и сгенерировал все 4!=24 перестановки за 0.001 секунд, что довольно быстро.

![](Aspose.Words.b733c9a5-6fc5-4575-bb81-afe6f7e27189.006.png)

*Рисунок 3.1.1 Результаты работы на массиве a = [1,2,3,6]*

Но как мы знаем что у любого алгоритма, который генерирует перестановки сложность O(n!), то есть с увеличением n, время работы алгоритма очень быстро увеличивается. Проверим это на практике на массиве a=[1,2,3,6,9,10,11,12,13,14]. Как можно вычислить у нас будет 10!= 3 628 800 перестановок. Все перестановки показать не получится, но давайте посмотрим на время, за которое алгоритм сработал. Это видно на рис. 3.1.2. 

![](Aspose.Words.b733c9a5-6fc5-4575-bb81-afe6f7e27189.007.png)

*Рисунок 3.1.2 Результаты работы на массиве a = [1,2,3,6,9,10,11,12,13,14]*

Как мы видим понадобилось всего лишь 9 секунд, это не так и много.      

Но давайте увеличим количество элементов в массиве хотя бы на один, то есть массив a=[1,2,3,6,9,10,11,12,13,14,15] и в нём 11 элементов. Количество перестановок в нашем случае будет равняться 11!=39 916 800. Как мы видим из рис. 3.1.3 время работы программы уже  96 секунд, то есть с добавлением одного элемента время работы увеличилось в 16 раз!

![](Aspose.Words.b733c9a5-6fc5-4575-bb81-afe6f7e27189.008.png)

*Рисунок 3.1.3 Результаты работы на массиве a = [1,2,3,6,9,10,11,12,13,14,15]*

И на самом деле если n>13, то даже самая быстрая машина за 18 часов не сможет получить все перестановки. Это простое следствие того факта, что n! растёт весьма быстро с ростом n.

## 2. <a name="_toc131123603"></a>Тестирование алгоритма динамического программирования для генерации всех разбиений числа на слагаемые

Давайте для начала протестируем алгоритм на примере, который был в теории для  n=5. Как мы видим из рис. 3.2.1 алгоритм сработал верно и выдал все разбиения числа 5 на слагаемые, и причём время работы очень мало – 0.001 секунд.

![](Aspose.Words.b733c9a5-6fc5-4575-bb81-afe6f7e27189.009.png)

*Рисунок 3.2.1 Результаты работы при n = 5*

Но как мы помним из теории, количество разбиений числа n при n→∞ растёт экспоненциально, то есть очень и очень быстро. Давайте, например, протестируем алгоритм при n=70. Как мы видим на рис. 3.2.2 время работы уже 11 секунд. То есть время работы заметно увеличилось.

![](Aspose.Words.b733c9a5-6fc5-4575-bb81-afe6f7e27189.010.png)

*Рисунок 3.2.2 Результаты работы при n = 70*

Следующий тест сделаем для n=80. Как мы видим на рис. 3.2.3 время работы уже составило 43 секунды, то есть по сравнению с прошлым результатом увеличилось в 3 раза.

![](Aspose.Words.b733c9a5-6fc5-4575-bb81-afe6f7e27189.011.png)

*Рисунок 3.2.3 Результаты работы при n = 80*

И заметим, что уже при n>100 количество разбиений по асимптотической формуле будет больше одного миллиарда, и за разумное время машина не сгенерирует все возможные способы.

## 3. <a name="_toc131123604"></a>Тестирование алгоритма Карла Фридриха Гинденбурга

Для начала протестируем действия данного алгоритма на примере из теории, то есть для n=8 и m=4. Как мы видим из рис. 3.3.1 алгоритм сработал верно, и очень быстро, за 0.001 секунд.

![](Aspose.Words.b733c9a5-6fc5-4575-bb81-afe6f7e27189.012.png)

*Рисунок 3.3.1 Результаты работы при n = 8 и m = 4*

Как мы знаем, количество разбиение растёт экспоненциально, поэтому давайте увеличим наши входные параметры. Пусть n=100 и m=20. Как мы видим на рис. 3.3.2 время работы алгоритма уже составляет 30 секунд.

![](Aspose.Words.b733c9a5-6fc5-4575-bb81-afe6f7e27189.013.png)

*Рисунок 3.3.2 Результаты работы при n = 100 и m = 20*

Далее понятно, что если мы будем увеличивать наши входные параметры, то за адекватное время машина не сможет сгенерировать все разбиения числа.

# <a name="_toc131123605"></a>Заключение	

В рамках данной курсовой работы была изучена различная литература по теме генерации комбинаторных объектов, рассмотрены различные алгоритмы и их особенности, а также разработаны и протестированы программы, реализующие эти алгоритмы.

Были рассмотрены классические алгоритмы генерации комбинаторных объектов, такие как алгоритм Хипа, алгоритм Штейнхауза-Джонсона-Троттера, динамический алгоритм для генерации всех разбиений числа, а также алгоритм Карла Фридриха Гинденбурга.

В заключение можно отметить, что генерация комбинаторных объектов является важной и актуальной задачей в математике и информатике. Благодаря различным методам генерации комбинаторных объектов можно решать множество задач, связанных с различными областями знаний, включая теорию графов, криптографию, теорию чисел и др.

# <a name="_toc131123606"></a>Список литературы

1. Положение о курсовых работах (проектах) в федеральном государственном бюджетном образовательном учреждении высшего образования «Российский экономический университет имени Г. В. Плеханова».
1. ГОСТ 2.105-95. ЕСКД. Общие требования к текстовым документам.
1. ГОСТ Р 54593-2011. Информационные технологии. Свободное программное обеспечение. Общие положения.
1. Комбинаторика: методы, результаты, проблемы / под ред. В. Д. Белоусова. Москва: Наука, 1975. 544 с.
1. Мендельсон, Б. Комбинаторика: введение в математический анализ. Москва: Наука, 1984. 296 с.
1. Косточка, А. В. Комбинаторика: генерация комбинаторных объектов. Москва: МФТИ, 2017. 220 с.
1. Кузнецов, А. А. Элементы комбинаторики: перестановки, размещения, сочетания. Москва: Логос, 2005. 224 с.
1. Штарев, А. М. Комбинаторика. Москва: МЦНМО, 2015. 400 с.
1. Горбачев, А. В. Комбинаторика: генерация комбинаторных объектов. Москва: МГУ, 2012. 336 с.
1. Голубцов, В. В. Комбинаторика: задачи, теория, методы. Москва: Издательство Физико-математической литературы, 2002. 256 с.
1. Зельдин, И. А. Комбинаторика для начинающих. Москва: МЦНМО, 2010. 240 с.
1. Малаховский, В. А. Комбинаторика: задачи и теория. Москва: МЦНМО, 2013. 288 с.
1. Попов, В. Н. Комбинаторика. Москва: Издательство ЛКИ, 2005. 256 с.
1. Смоляков, С. А. Комбинаторика: основы теории и приложения. Москва: ФИЗМАТЛИТ, 2007. 432 с.
1. Липский В. Комбинаторика для программистов. –М. :Мир, 1988.–213 с.


# <a name="_toc43133212"></a><a name="_toc130205999"></a><a name="_toc131123607"></a>Приложения
## <a name="_toc131123608"></a>Приложение 1
### <a name="_toc131123609"></a>Алгоритм Карла Фридриха Гинденбурга
**import** **java.util.Arrays**;

**public** **class** **Solution** {

`    `// вывести все разбиения числа n на m слагаемых

`    `**public** **static** **void** **printNumberPartition**(**int** n, **int** m) {

`        `**int**[] part = **new** **int**[m];

`        `Arrays.fill(part, **1**);

`        `part[**0**] = n - m + **1**;

`        `**for** (; ; ) {

`            `System.out.println(Arrays.toString(part));

`            `**if** (part[**0**] < part[**1**] - **1**) {

`                `part[**0**] -= **1**;

`                `part[**1**] += **1**;

`            `} **else** {

`                `**int** j = -**1**; // изначально предполагаем, что такого элемента нет

`                `**int** s = part[**0**] - **1**;

`                `**for** (**int** i = **1**; i < part.length; i++) {

`                    `**if** (part[i] < part[**0**] - **1**) {

`                        `j = i;

`                        `**break**;

`                    `}

`                    `s += part[i];

`                `}

`                `**if** (j == -**1**) {

`                    `**break**;

`                `}

`                `part[j] += **1**;

`                `**for** (**int** i = **1**; i < j; i++) {

`                    `part[i] = part[j];

`                    `s -= part[j];

`                `}

`                `part[**0**] = s;

`            `}

`        `}

`    `}   

}


## <a name="_toc131123610"></a>**Приложение 2**
### <a name="_toc131123611"></a>**Алгоритм Хипа**
**public** **static** **void** **HipAlgorithm**(**int**[] nums, **int** k) {

`        `**if** (k == **1**) {

`            `System.out.println(Arrays.toString(nums));

`        `} **else** {

`            `**for** (**int** i = **0**; i < k; i++) {

`                `HipAlgorithm(nums, k - **1**);

`                `**if** (k % **2** == **0**) {

`                    `swap(nums, i, k - **1**);

`                `} **else** {

`                    `swap(nums, **0**, k - **1**);

`                `}

`            `}

`        `}

`    `}

**public** **static** **void** **swap**(**int**[] arr, **int** i, **int** i1) {

`        `**int** tmp = arr[i];

`        `arr[i] = arr[i1];

`        `arr[i1] = tmp;

`    `}

## <a name="_toc131123612"></a>**Приложение 3**
### <a name="_toc131123613"></a>**Алгоритм генерации разбиения числа с помощью динамического программирования**
**import** **java.util.Arrays**;

**public** **class** **Solution** {

`    `**public** **static** **int**[] **getNextPartition**(**int**[] partition) { // вернёт ссылку на целочисенный массив, следующее разбиение

`        `**if** (partition.length == **1**) { // разбиений больше нет

`            `**return** **null**;

`        `}

`        `**int** minIndex = **0**;

`        `**for** (**int** i = **0**; i < partition.length - **1**; i++) { // ищем самый минимальный элемент от начала до предпоследнего

`            `**if** (partition[i] < partition[minIndex]) {

`                `minIndex = i;

`            `}

`        `}

`        `partition[minIndex] += **1**; // увеличиваем минимальный элемент 1

`        `partition[partition.length - **1**] -= **1**; // уменьшаем последний элемент на 1

`        `minIndex += **1**;

`        `**int** partSum = **0**;

`        `**for** (**int** i = minIndex; i < partition.length; i++) {

`            `partSum += partition[i];

`        `}

`        `**int**[] nextPartition = Arrays.copyOf(partition, minIndex + partSum);

`        `**for** (**int** i = minIndex; i < nextPartition.length; i++) {

`            `nextPartition[i] = **1**;

`        `}

`        `**return** nextPartition;

`    `}

`    `**public** **static** **void** **printAllNumberPartitions**(**int** number) {

`        `**int**[] partition = **new** **int**[number];

`        `Arrays.fill(partition, **1**);

`        `**for** (; partition != **null**;) {

`            `System.out.println(Arrays.toString(partition));

`            `partition = getNextPartition(partition);

`        `}

`    `}
35
